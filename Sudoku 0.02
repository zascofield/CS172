/**
 * The Sudoku solver.
 *
 * @author Luke Bass
 * @author Zachary Scofield
 */
public class Sudoku {

    /** Prints the solution to the puzzle in the specified directory. */
    public static void main(String[] args) {
        String puzzle = new In("sudoku1.txt").readAll();
        Square[][] grid = createSquares(puzzle);
        solve(grid);
        StdOut.println(toString(grid));
    }

    /** Returns a new Location object with the specified row and column. */
    static Location createLocation(int r, int c) {
        Location l = new Location();
        l.row = r;
        l.column = c;
        return l;
    }

    /** Returns an array of the eight Locations in the same row as here. */
    static Location[] findRow(Location here) {
        Location[] l = new Location[8];
        int c = 0;
        for (int i = 0; i <= l.length; i++) {
            if (i != here.column) {
                l[c] = createLocation(here.row, i);
                c++;
            }
        }
        return l;
    }

    /** Returns an array of the eight Locations in the same column as here. */
    static Location[] findColumn(Location here) {
        Location[] l = new Location[8];
        int c = 0;
        for (int i = 0; i <= l.length; i++) {
            if (i != here.row) {
                l[c] = createLocation(i, here.column);
                c++;
            }
        }
        return l;
    }

    /** Returns an array of the eight Locations in the same 3x3 block as here. */
    static Location[] findBlock(Location here) {
        Location[] l = new Location[8];
        int c = 0;
        int cornerX = here.row - (here.row % 3);
        int cornerY = here.column - (here.column % 3);
        for (int i = cornerX; i <= cornerX + 2; i++) {
            for (int j = cornerY; j <= cornerY + 2; j++) {
                if (!(i == here.row && j == here.column)) {
                    l[c] = createLocation(i, j);
                    c++;
                }
            }
        }
        return l;
    }

    /**
     * Returns a 9x9 array of Squares, each of which has value 0 and knows about the other squares in its row,
     * column, and block.
     */
    static Square[][] createSquares() {
        Square[][] s = new Square[9][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                s[i][j] = new Square();
                s[i][j].value = 0;
                //creates the three arrays that each square on the grid holds
                s[i][j].row = new Square[8];
                s[i][j].column = new Square[8];
                s[i][j].block = new Square[8];
            }
        }

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
              Location[] row = findRow(createLocation(i, j));
              Location[] column = findColumn(createLocation(i, j));
              Location[] block = findBlock(createLocation(i, j));
              for (int k = 0; k < 8; k++) {
                  //fills in all three arrays
                  s[i][j].row[k] = s[row[k].row][row[k].column];
                  s[i][j].column[k] = s[column[k].row][column[k].column];
                  s[i][j].block[k] = s[block[k].row][block[k].column];
              }
            }
        }
        return s;
    }

    /** Returns a String representing grid, showing the numbers (or . for squares with value 0). */
    static String toString(Square[][] grid) {
        Sudoku.createSquares();
        //ts is short for toString
        String ts = new String("");
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (grid[r][c].value == 0) {
                    ts = ts + ".";
                } else {
                    ts = ts + (String.valueOf(grid[r][c].value));
                }
            }
            //need to make sure that the grid is spaced out evenly by making new lines
           ts = ts + "\n";
        }
        return ts;
    }

    /**
     * Returns a 9x9 array of Squares, each of which has value 0 and knows about the other squares in its row,
     * column, and block. Any numbers in diagram are filled in to the grid; empty squares should be given as
     * periods.
     */
    static Square[][] createSquares(String diagram) {
        Square[][] newS = Sudoku.createSquares();
        int c = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (diagram.charAt(c) == '\n') {
                    c ++;
                }
                if (diagram.charAt(c) == '.') {
                    newS[i][j].value = 0;
                } else {
                    newS[i][j].value = diagram.charAt(c) - '0';
                }
                c ++;
            }
        }
        return newS;
    }

    /**
     * Returns a boolean array of length 10. For each digit, the corresponding entry in the array is true
     * if that number does not appear elsewhere in s's row, column, or block.
     */
    static boolean[] findValidNumbers(Square s) {
        boolean[] v = new boolean[10];
        for (int i = 0; i < 10; i++) {
            v[i] = true;
            for (int j = 0; j < 8; j++) {
                // runs through all the scenarios where the value would be invalid
                if (s.row[j].value == i) {
                    v[i] = false;
                    break;
                }
                if (s.column[j].value == i) {
                    v[i] = false;
                    break;
                }
                if (s.block[j].value == i) {
                    v[i] = false;
                    break;
                }
            }
        }
        return v;
    }

    /**
     * Returns true if grid can be solved. If so, grid is modified to fill in that solution.
     */
    static boolean solve(Square[][] grid) {
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (grid[r][c].value == 0) {
                    Square s = grid[r][c];
                    for (int i = 1; i < 10; i++) {
                        if (findValidNumbers(s)[i]) {
                            grid[r][c].value = i;
                            if (solve(grid)) {
                                return true;
                            } else {
                                grid[r][c].value = 0;
                            }
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

}
